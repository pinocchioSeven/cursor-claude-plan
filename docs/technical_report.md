# Cursor/Claude Code“Plan模式”原理调研技术报告
> **作者：李彦琦**
> **日期：2026年1月28日**

## 1. 背景与问题动机

随着大语言模型在代码生成领域的能力提升，AI编程工具已从“代码补全”演进到“任务级代码生成”。
然而在实际使用中，端到端代码生成的稳定性存在一下问题：

- 代码结构混乱，模块职责不清；
- 依赖关系未显式声明，后续调试困难；
- 一旦生成错误，修正成本高，需反复重试。

而近期Cursor和Claude Code引入的 **“Plan模式”**（Planning Mode）提供了一种新思路：**先输出开发计划，再分步实现**。
其实这一“先规划、后实现”的思路，与我之前了解到的2023年Agent领域提出的ReWOO（Reasoning WithOut Observation）框架高度一致——两者均强调将推理（Planning）与执行（Execution）解耦，以提升复杂任务的可控性与可靠性。

**“Plan模式”**，尝试在交互层面解决这一矛盾：即
在生成代码之前，先由模型给出一份可审查、可修改的开发计划，再进入实现阶段。这与Agent研究领域中的多阶段推理范式高度一致。

本调研目标：

- 理解 Cursor / Claude Code中Plan模式的真实作用；

- 拆解技术实现范式；

- 抽象出可复现、可落地的Plan技术架构。

## 2. Plan模式

### 2.1 表层表现

在Cursor / Claude Code 中，Plan模式通常表现为：

1. 用户提出一个较复杂的开发目标：“给这个项目增加登录功能”

2. AI不立即修改代码，而是先输出一个明确的实施计划，例如：

- 需要修改哪些文件

- 每一步要做什么

- 是否需要用户确认

关键是：Plan阶段不会直接写代码，而是“先想清楚怎么做”

### 2.2 核心定位

Plan模式并非简单地“不写代码”，而是一种**结构化任务分解机制**。其核心思想是：

> **将模糊需求转化为可执行的架构蓝图，由人类确认后再交由AI实现。**

典型输出包括：
- 项目目录结构（如 `src/`, `tests/`）
- 模块划分与职责说明（如“auth模块负责JWT验证”）
- 关键函数签名（如 `def create_user(email: str) -> User`）
- 依赖项列表（如 `flask`, `pydantic`）

其核心目标并非生成可执行结果，而是生成一个可供人类审查和干预的中间表示。

这种模式保留了人类对关键决策的控制权的同时，将“需求分析-架构设计”环节部分实现了自动化。

## 3. 技术实现机制分析

通过查阅官方文档、社区讨论及实验验证，我认为Plan模式的实现建立在Prompt工程、结构化输出约束与上下文管理机制之上。

### 3.1 角色化Prompt工程

Plan模式的本质，是一个强约束的**Planning Prompt**。例如，系统提示词可能类似：

> “你是一名有10年经验的后端架构师。请为以下需求生成一份可执行的开发计划。不要输出任何代码。”

这种prompt引导LLM进入“规划者”角色。在测试中发现，若省略此约束，模型仍会混入代码片段，说明**角色指令的有效性高度依赖prompt的精确性**。

### 3.2 结构化输出控制

Plan必须是**机器可读的结构化数据**，是作为一种准结构化的中间表示。主流方案包括：

- 强制 JSON 输出（Claude系列）；
- Function Calling + JSON Schema（GPT 系列）。

我在原型实现中选择了Claude 3 Haiku，因其在结构化输出稳定性上表现优于GPT-3.5（后者常忽略schema约束）。
这也反映出：**Plan模式的可靠性是需要高度依赖底层LLM的指令遵循能力的**。

### 3.3 多步推理的隐式展开

虽然用户只看到最终Plan，但模型内部实际执行了链式推理（Chain-of-Thought）：
1. 需求解析
2. 功能拆解
3. 模块抽象
4. 文件映射
5. 依赖推导

这一过程类似于人类设计师的思考流。但是由于模型无法回溯的特点，初始prompt的清晰度至关重要。

### 3.4 IDE上下文集成

在Cursor等工具中，Plan并非一次性输出，而是：
- 作为对话上下文缓存；
- 后续代码生成时自动引用；
- 支持用户编辑后重新生成。

这种 **“人机协同”** ，这也是当前纯API方案难以复现的部分。

## 4. 与传统代码生成的对比思考

| 维度 | 传统代码生成 | Plan模式 |
|------|-------------|---------|
| **输出目标** | 可运行代码 | 可审查的设计文档 |
| **用户控制力** | 低（黑盒） | 高（可干预设计） |
| **错误成本** | 高（需重跑） | 低（在规划阶段修正） |
| **适用场景** | 小脚本、单函数 | 中大型项目、多模块系统 |

**我的观察**：Plan模式更适合**有明确架构意识的开发者**。对于初学者，可能反而增加认知负担。

同时，从团队协作角度看，Plan本身可作为**轻量级设计文档**，便于成员对齐理解，实现高效协作目标。

## 5. 可行性验证、局限与个人思考

通过构建简化原型（见代码部分），我验证了以下观点：

1. Plan模式的核心并非算法创新，而是把LLM转变为“协作者”；
2. 结构化输出必须依赖LLM的格式控制能力。

在实验过程中，我也发现了Plan模式存在的几个现实问题：
- **幻觉风险**：模型可能虚构不存在的库；
- **粒度失衡**：有时Plan过于粗略，有时又过度设计（例如会提前定义多个函数）；
- **无反馈机制**：即使用户指出Plan错误，模型也无法自动修正历史上下文。

**个人思考**：我认为，Plan不是为了让模型想得更聪明，而是为了让系统更可控。

未来值得进一步研究的方向可以包括：

- 如何让模型理解架构权衡与技术债；
- 如何引入执行反馈以自动修正Plan。

> **备注**：本报告基于公开资料、API实验及个人开发经验撰写。